
## **PCB (Process Control Block)**

> 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는구조체

![](https://i.imgur.com/nDwTpxn.png)


- 프로세스의 상태 관리와 문맥 교환(Context Switching)을 위해서 필요
- PCB는 운영체제가 프로세스를 표현한 것
- 프로세스가 생성될 때마다 고유의 PCB 가 생성되며, 프로세스가 완료되면 PCB는 제거됨
- 프로세스 스택에 쌓인다.

### 세부 정보
1. **Process ID** : 프로세스의 고유 ID
2. **Process State** : 프로세스의 상태 (Create, Ready, Running 등등)
3. **Program Counter** : 프로세스를 위해 실행될 다음 명령어의 주소
4. **Register** : Accumulator, General Register 등을 포함하는 CPU Register의 값
5. **CPU Scheduling Information** : 우선순위, 최종 실행시간, CPU 점유시간 등
6. **Memory management information** : 해당 프로세스의 주소 공간 정보
7. **I/O Status** : 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등

### 과정
1. 프로그램 실행
2. 프로세스 생성
3. 프로세스 주소 공간 (코드, 데이터, 스택) 생성
4. 이 프로세스의 메타데이터들이 PCB에 저장

## **문맥 교환(Context Switching**)

> 현재 진행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 진행할 프로세스의 정보를 PCB에서 읽어 적용하는 과정

### 왜?
- CPU는 한 번에 하나의 프로세스만 수행 가능
- 근데 여러 프로세스 필요
- 여러 개의 프로세스를 번갈아가며 수행

### 동시성 vs 병렬성

- 동시성
	- 조금씩 여러 작업을 돌아가면서 진행하는 방법
	- Context Switching을 말함
- 병렬성
	- 프로세서 하나에 코어 여러 개가 달려서 각각 동시에 작업들을 수행하는 것
	- 듀얼 코어 쿼드코어 옥타코어 등 멀티코어 프로세서

### 과정

![](https://i.imgur.com/yKA7VQ1.png)

> IDLE란 프로세스가 실행하고 있지 않은 상태를 말함

### 언제 일어나는데?

> 인터럽트가 발생했을 때 일어남.
> 즉, CPU가 프로그램을 실행하고 있을 때 실행 중인 프로그램 밖에서 예외 상황이 발생하여 처리가 필요한 경우

1. 입/출력을 요청할 때
2. CPU 사용시간이 만료되었을 때
3. 자식 프로세스를 만들 때
4. 인터럽트 처리를 기다릴 때

### 비용?

> 당근 추가 작업이 발생함에 따라 추가적인 오버헤드 발생

극단적인 경우 새로 생성하는 비용과 비슷한 경우도 존재함

### 스레드에서는? 

> 스레드 단위로도 콘텍스트 스위칭이 가능

스레드는 콘텍스트 스위칭될 때 
스택(Stack)을 제외한 코드(Code), 데이터(Data), 힙(Heap) 영역은 프로세스의 것이기 때문에 
자신의 PCB에는 스택 및 간단한 정보만 저장해서 프로세스 콘텍스트 스위칭보다 빠름

스레드 특수한 스레드 예를 들어 고루틴, rust 이런 특수한. 또 다르다고 합니다.

### 비선점 스케줄링

> 어떤 프로세스가 CPU를 점유하고 있다면 해당 프로세스의 작업이 완료 될 때까지 다른 프로세스는 CPU를 사용할 수 없다.

해당 프로세스는 자기 일이 끝날때까지 CPU를 양보하지 않음
Context Switching을 최소화 할 수 있지만, 급하게 처리 되어야 할 일이 있어도 처리하지 못하게 될 수도 있다.

#### FCFS (First Come First Service)

프로세스가 Ready Queue에 도착한 순서대로 CPU에 할당하는 방식

- 작업 완료 시간을 예측할 수 있지만, 급하게 처리해야 하면서 짧은 처리 시간을 가진 작업이 자기 순서를 한참 기다려야 할 수도 있다.
	- 이러한 상황을 Convoy Effect, 호위 상태라고 한다.

#### SJF (Shortest Job First)

프로세스를 CPU 처리 시간이 짧은 순서대로 CPU에 할당하는 방식

- 모든 방식을 통틀어 평균 대기 시간을 가장 짧게 만드는 방식으로 알려져 있음.
- 그러나 CPU 처리 시간이 긴 프로세스는 뒤로, 뒤로 계속 밀려난다.
	- 자기 순서가 오지 않는 상황이 발생 할 수도 있다. 이러한 상황을 기아 상태라고 한다.

#### HRN (Highest Response Ratio Next)

SJF 방식에서 발생할 수 있는 기아 상태를 해결하기 위한 방식

- 우선순위 처리를 단순 CPU 처리시간이 아닌, Ready Queue 에서 대기한 시간까지 고려해서 결정한다.  
	- `((대기 시간 + CPU 처리 시간) / CPU 처리 시간)`  
- 기다린 시간에 비례하여 우선순위를 높이는 방식으로 에이징 기법이라고 한다.

### 선점 스케줄링

> 어떤 프로세스가 CPU를 점유하고 있을 때 우선순위가 높은 다른 프로세스가 점유를 빼앗아 CPU를 점유할 수 있다. 
> 긴급히 처리되어야 할 프로세스가 먼저 처리 될 수 있지만, Context Switching이 자주 일어날 수 있다.

#### SRT (Shortest Remaining Time)

SJF 방식을 선점 스케줄링 방식으로 변경 한 방식

- CPU를 점유중인 프로세스보다 남은 CPU 처리 시간이 짧은 프로세스가 Ready Queue에 들어올 경우에는 CPU 점유를 뺏어버릴 수 있다.

#### 라운드로빈 (Round-Robin)

FCFS 방식에 선점 방식과 Time Quantum 개념을 추가한 방식

- 프로세스마다 CPU를 연속적으로 사용할 수 있는 시간에 제한을 주는데, 
	- 이를 Time Quantum이라고 한다.
- Time Quantum시간만큼 CPU를 점유했다면,
	- 해당 프로세스로부터 자원을 회수하고
		- Ready Quene의 가장 뒤로 보낸다. 
- Time Quantum이 너무 길다면, 기존의 문제점인 호위상태가, 너무 짧다면 Context Switching이 자주 일어나게 된다.

큐 1 2 3 4 5 
1번 1초 2번 1초 ... 5번 1초 1번 1초 2번 1초 /////
계속 돌아가면서 한다~

#### 다단계 큐 (Multi-Level Queue)

프로세스를 그룹으로 나누고, 그룹마다 Queue를 둔다. 
- Ready Queue가 여러개인 것이다. 

또한 각각의 Queue마다 다른 스케줄링 방식을 적용할 수도 있다. 

~

알아서 찾아보기.