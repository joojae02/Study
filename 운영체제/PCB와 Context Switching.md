## **PCB (Process Control Block)**

> 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는구조체

![](https://i.imgur.com/nDwTpxn.png)


- 프로세스의 상태 관리와 문맥 교환(Context Switching)을 위해서 필요
- PCB는 운영체제가 프로세스를 표현한 것
- 프로세스가 생성될 때마다 고유의 PCB 가 생성되며, 프로세스가 완료되면 PCB는 제거됨

### 세부 정보
1. **Process ID** : 프로세스의 고유 ID
2. **Process State** : 프로세스의 상태 (Create, Ready, Running 등등)
3. **Program Counter** : 프로세스를 위해 실행될 다음 명령어의 주소
4. **Register** : Accumulator, General Register 등을 포함하는 CPU Register의 값
5. **CPU Scheduling Information** : 우선순위, 최종 실행시간, CPU 점유시간 등
6. **Memory management information** : 해당 프로세스의 주소 공간 정보
7. **I/O Status** : 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등

### 과정
1. 프로그램 실행
2. 프로세스 생성
3. 프로세스 주소 공간 (코드, 데이터, 스택) 생성
4. 이 프로세스의 메타데이터들이 PCB에 저장

## **문맥 교환(Context Switching**

> 현재 진행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 진행할 프로세스의 정보를 PCB에서 읽어 적용하는 과정

### 왜?
- CPU는 한 번에 하나의 프로세스만 수행 가능
- 근데 여러 프로세스 필요
- 여러 개의 프로세스를 번갈아가며 수행

### 동시성 vs 병렬성

- 동시성
	- 조금씩 여러 작업을 돌아가면서 진행하는 방법
	- Context Switching을 말함
- 병렬성
	- 프로세서 하나에 코어 여러 개가 달려서 각각 동시에 작업들을 수행하는 것
	- 듀얼 코어 쿼드코어 옥타코어 등 멀티코어 프로세서

### 과정

![](https://i.imgur.com/yKA7VQ1.png)

> IDLE란 프로세스가 실행하고 있지 않은 상태를 말함

### 언제 일어나는데?

> 인터럽트가 발생했을 때 일어남.
> 즉, CPU가 프로그램을 실행하고 있을 때 실행 중인 프로그램 밖에서 예외 상황이 발생하여 처리가 필요한 경우

1. 입/출력을 요청할 때
2. CPU 사용시간이 만료되었을 때
3. 자식 프로세스를 만들 때
4. 인터럽트 처리를 기다릴 때

### 비용?

> 당근 추가 작업이 발생함에 따라 추가적인 오버헤드 발생

극단적인 경우 새로 생성하는 비용과 비슷한 경우도 존재함

### 스레드에서는? 

> 스레드 단위로도 콘텍스트 스위칭이 가능

스레드는 콘텍스트 스위칭될 때 
스택(Stack)을 제외한 코드(Code), 데이터(Data), 힙(Heap) 영역은 프로세스의 것이기 때문에 
자신의 PCB에는 스택 및 간단한 정보만 저장해서 프로세스 콘텍스트 스위칭보다 빠름

