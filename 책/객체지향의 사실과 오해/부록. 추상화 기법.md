# 부록. 추상화 기법
## 추상화 기법

> 추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.

- **분류와 인스턴스화**
	- **분류**는 객체의 세부사항을 숨기고 인스턴스간 공유하는 공통 특성을 기반으로 범주를 형성하는 과정이다.
	- 분류의 역은 범주로부터 객체를 생성하는 **인스턴스화** 과정이다.
- **일반화와 특수화**
	- **일반화**는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다.
	- 일반화의 역을 **특수화**라 한다.
- **집합과 분해**
	- **집합**은 부분과 관련된 세부사항을 숨기고 부분을 사용해 전체를 형성하는 과정이다.
	- 집합의 반대 과정은 전체를 부분으로 분리하는 **분해** 과정이다.

## 분류와 인스턴스화

### 개념과 범주

버스, 트럭, 승용차.. 등등 -> 자동차
다양한 종류의 나무, 가로수 등등 -> 나무

공통점을 바탕으로 서로 다른 객체를 하나의 개념으로 분류할 수 있다.

객체를 분류하고 **범주**로 묶는 것은 특정 집합에 공통 **개념**을 적용하는 것을 의미한다.

> 세상에 존재하는 객체에 개념을 적용하는 과정을 **분류**하고 한다.

분류는 객체를 특정 개념을 나타내는 집합의 구성 요소로 포함시킨다.

> 수많은 개별적인 현상들을 **객체**
> 하나의 개념을 **타입**

다시 말해
분류는 객체를 타입과 연관시키는 것

분류의 역은 타입에 해당하는 객체를 생성하는 것
- **인스턴스화** 또는 **예시**라 한다.

### 타입

타입을 객체의 분류 장치로서 적용할 수 있으려면 세가지 관점에서 정의가 필요하다.

- 심볼
	- 타입을 가르키는 간략한 이름 또는 명칭
- 내연
	- 타입의 완전한 정의.
	- 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
- 외연
	- 타입에 속하는 모든 객체들의 집합

자동차를 예시로 들면

심볼 - 자동차
내연 - 원동기를 동력원으로해서 주행하는 사람이나 화물을 운반하는 기계
외연 - (여러 종류의 자동차들)

### 외연과 집합

타입의 외연은 타입에 속하는 객체들의 집합으로 표현된다.
집합은 외연의 또다른 명칭.

객체는 여러 집합에 포함 가능함.

- **단일 분류**
- **다중 분류**

하나의 타입에만 속하면 **단일 분류**
여러 타입에 속하면 **다중 분류**

객체가 한 집합에서 다른 집합의 원소로 타입을 변경할 수 있다면?
- **동적 분류**

변경할 수 없다면??
- **정적 분류**

다중 분류와 동적 분류는 개념적 관점에서는 유용하지만 실제 구현은 쉽지 않다.

### 클래스

타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.

> 클래스는 객체가 공유하는 본질적인 속성을 정의한다.

동일한 범주에 속하면 동일한 클래스의 인스턴스.
동일한 속성을 가져야 한다.

## 일반화와 특수화

### 범주의 계층

린네의 범주 계층은 범주 간의 계층적인 구조를 가진다.

- 계
- 문
- 강
- 목
- 과
- 속
- 종

세부적인 범주가 하위에 위치하고 일반적인 범주가 상위에 위치한다.

상위에 위치한 범주를 하위 범주의 **일반화**라 하고,
하위 범주는 상위 범주의 **특수화**라 한다.

### 서브타입

객체지향에서 범주는 개념을 의미하고 개념은 타입을 의미한다.
따라서 일반화와 특수화는 계층 구조 안 존재하는 타입 간 관계를 의미한다.

어떤 타입이 다른 타입보다 일반적이라면 **슈퍼타입**,
어떤 타입이 다른 타입보다 특수하다면 **서브타입**

슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화이다.

이 일반화와 특수화는 범주 간 논리적인 추론을 가능케 한다.

> 어떤 범주에 속하는 다른 객체가 특정 속성을 가지고 있으면 그 범주, 하위 범주에 속하는 다른 객체도 그 속성을 가지고 있을 것이라 추론할 수 있다.

또한 
- 100% 규칙
- Is-a 규칙
두가지 규칙을 준수해야 한다.

각각
- 슈퍼타입의 정의가 100% 서브타입에 적용되어야 한다.
- 서브타입의 모든 인스턴스는 슈퍼타입의 집합에 포함되어야 한다.

### 상속

일반화 특수화 관계를 구현하는 가장 일반적인 방법은 **상속**이다.

그러나 모든 상속 관계가 일반화 관계는 아님.
- 서브타입이 되기 위해서는 슈퍼타입에 순응해야 함.

순응은 두가지 종류가 존재한다.
- 구조적인 순응
- 행위적인 순응

두가지 모두 서브타입의 슈퍼타입에 대한 대체 가능성을 의미한다.

구조적인 순응은 타입의 내연과 관련된 100% 규칙을 의미.
-  서브타입은 슈퍼타입이 가지고 있는 속성과 100% 일치해야한다.

행위적인 순응은 타입의 행위에 관한 것이다.
- 흔히 리스코프 치환 원칙이라고 한다.
슈퍼 타입이 A 메서드를 가진다면 서브타입 또한 A 메서드를 가져야한다.

또한 상속은 코드 중복을 방지, 공통 코드를 재사용할 수 있게 해준다.

그래서 상속은
- 서브타이핑
- 서브클래싱
두가지로 사용될 수 있다.

서브타이핑
- 서브 클래스가 슈퍼클래스를 대체할 수 있는 경우
서브클래싱
- 서브 클래스가 슈퍼클래스를 대체할 수 없는 경우


서브타이핑은 설계의 유연성이 목표
서브클래싱은 코드의 중복 제거, 재사용이 목적

> 서브 타이핑 == 인터페이스 상속
> 서브 클래싱 == 구현 상속

여러 클래스로 구성된 상속 계층에서 메시지를 이해하는 방법은 클래스간 **위임**을 사용하는 것이다.

어떤 클래스가 수신된 메시지를 이해할 수 없다면 부모 클래스로 위임한다.

클래스가 없는 프로토타입 기반 언어에선 상속은 객체 간의 관계로 이뤄진다.

> 어떤 타입의 객체를 특정 객체 타입의 특수화로 만들거나 행동을 공유할 수 있게 만들고 싶은 경우 객체간 상속 관계를 통해 연결한다.

## 집합과 분해

### 계층적인 복잡성

- 복잡성은 계층의 형태를 띈다.
- 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 안정적인 형태의 수와 분포에 의존한다.

안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**이라 한다.
반대로 전체를 부분으로 분할하는 행위를 **분해**라 한다.

집합은 많은 수의 사물을 하나의 단위로 다룸으로 복잡성을 줄여준다.
- 불필요한 세부사항을 배제하고 대상을 다룰 수 있게 해줌.
- 불필요한 세부사항을 추상화 한다.

집합은 세부사항을 감춰주기 때문에 동시에 캡슐화 메커니즘이다.

### 합성 관계

> 객체와 객체 사이의 전체-부분 관계를 구현하기 위해서 **합성 관계**를 사용한다.

합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.

합성관계는 생명주기 측면에서 연관 관계보다 강하게 결합한다.
- 합성 관계는 하나가 제거되면 포함된 객체도 제거된다.

### 패키지

> 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성요소를 **패키지** 또는 **모듈**이라 한다.

전체적인 구조를 이해하기 위해 고려해야하는 요소를 줄일 수 있다.
클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮춘다.

패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.






